TODO:

	See "Colliders" below.

	Implement scalar multiplication of Velocity.
		- Don't forget the unit test.
	
	Implement division of Velocity by Time to get Acceleration.
		- Don't forget the unit test.

	Implement multiplication of mass by acceleration (and vice-versa) to get
		force.
		- Don't forget the unit test.

	Field::effect() accepts a list of particle IDs to affect and the ID of the
		particle to which the field is attached. Verify that the simulation
		passes the field owner's ID in the list of IDs when it should be
		affected and add a warning to the documentation not to double up effects
		on the field owner if a field affects both self and others.

	Implement comparison operators (partialOrd, others?) for Ticks.
	
	Write unit tests for:
		- utilities::is_within_radius()
		- utilities::measure_distance()
		- utilities::get_displacement_vector()
		- Vector2.get_unit_vector()
		- Vector2.get_magnitude()
		- Vector2.x()
		- Vector2.y()
		- Displacement.get_vector()
	
	Simulation.get_position() should not panic if a particle doesn't exist. It
		Should return an Option::None. Otherwise, having a field delete a
		particle, then attempting to find that particle (for example, in
		animation code) will cause a panic.
		- I should probably also add a method to get a collection containing the
			IDs of all existing particles, rather than forcing a user of the
			Simulation to keep track of the particles itself.
	
	It is probably necessary to somehow give the on_tick callback some way to
		store information between calls, similar to how Unity makes the user
		implement an entire class, which can be used to store any variables the
		user wants, to use the Update() method. Otherwise, on_tick may be very
		limited.
		- I already have this capability in Field effect() methods. I just need
			to make on_tick() a struct that implements a trait, similar to
			how I implemented Fields.
	
	Use Rust's pub(restricted) feature (probably pub(crate)) to hide things that
		need to be public within the library from users of the library.

	Consider removing affects_others() from the Field trait. It may be redundant
		now that triggers_on_fields() and triggers_on_particles() exist.

	Clean up warnings that appear when running cargo check or cargo test.

	When done, search the code for any remaining "TODO" comments.


V0 Goals
	- Get more Rust practice/knowledge.
	- Write a minimal, single-threaded, 2d physics engine and create a realtime,
		interactive, graphical demo.
	- Simulate an arbitary number of particles.
		+ Forces
		+ Position
		+ Velocity
		+ Fields
	- For the demo, use the library to allow creation of particles and
		application of forces in a running simulation.

Development process (not necessarily in order)
	- Design the library.
		+ Design the interface. 													[done]
		+ Design the structs.
		 	-> Design the struct methods.
		+ Design the simulation logic (how to keep track of particles, how to		[done?]
			apply the effects of fields, etc.).
			-> Make a Simulation struct to store everything that belongs to the
				active simulation.
	- Write structs and skeleton functions/methods based on the interface design.	[done]
	- Write failing tests.															[done]
		+ Starting to write these while working on the design, based on the
			methods under the "Interface", section, below, might be helpful for
			coming up with more of the design.
	- Implement the library.
		+ Don't forget about the design notes below, particularly the simulation
			notes and the tick() method's notes.
		+ Make sure the tests pass.
	- Write the demo.

Testing
	- The physics engine should be a library with unit (and integration?) tests.
	- Tests:
		+ A useful category of tests might be tests that apply known forces or
			velocities to particles and compare the results to the predictions
			of classical mechanics formulas for position, velocity, kinetic
			energy, etc. Due to the tick-based, discrete nature of the
			simulation, these tests will need to allow for some margin of error,
			based on the tick length and other precision settings.
		+ Test all of the basic building blocks of the library (e.g., the vector
			math structs and methods).

Interface (things to make available to users of the library)
	- The interface will probably mostly be methods of the Simulation struct.
	- Create a new simulation (new Simulation struct).
	- Set simulation parameters (simulation speed, tick length, other precision
		parameters).
		+ Define a Simulation struct to store everything involved in the
			simulation. Set all parameters through a constructor.
		+ Simulation::new(speed: /* number */, tick_length: /* number */)
			-> Simulation;
	- Create particles.
		+ fn create_particle(position: Vector2 /* or Position */,
			mass: /* number */, fields: Vec<Field>)
			-> /* particle ID: */ Uuid;
	- Delete particles.
		+ fn delete_particle(particle_id: Uuid);
	- Set particle properties?
		+ Don't allow mass, position, or fields to be modified for existing
			particles. These would all just lead to unnecessary headaches. E.g.,
			what happens to a particle's velocity if its mass changes? Would
			energy be conserved or would velocity stay constant? It may be fun
			to play with in a later version, but isn't worth implementing in v0.
	- Set velocity and acceleration directly?
		+ No. Not worth it for v0. This is meant to be "minimal."
	- Create fields and attach them to particles.
		+ Users of the library will need to be able to write functions that the
			library can call when it's processing field effects. This could
			probably be accomplished by providing a Field trait or using
			function pointers.
	- Remove fields?
		+ No. Not for v0.
	- View existing fields, check for the existence of a field of a given type.
		+ Don't do this for v0. There's probably no need to inspect particles
			like this for a minimal implementation.
	- Apply forces to particles.
		+ apply_force(particle_id: Uuid, force: Vector2 /* or Force */)
	- Start and pause the simulation?
		+ start();
		+ pause();
	- Elapsed ticks
		+ get_elapsed_ticks() -> /* number or Tick */;
			-> Possibly useful to alias a numeric type as Tick. Allows all
				references to Tick to be changed to a different underlying type
				if desired and might make the compiler catch some logic errors.
	- Elapsed time (simulated seconds since start of simulation)
		+ get_elapsed_time() -> /* number or SimTime */:
			-> Possibly useful to alias a numeric type as SimTime. Allows all
				references to SimTime to be changed to a different underlying
				type if desired and might make the compiler catch some logic
				errors.
	- Read information necessary/useful to render the simulation.
		+ particle position
			-> get_position(particle_id: Uuid) -> Vector2 /* or Position */;
		+ particle mass
			-> get_mass(particle_id: Uuid) -> /* number or Mass */;
				- It's probably a good idea to alias a numeric type as Mass.
					Then, it should be possible to change the underlying type in
					just one place if desired. This also makes the type system
					prevent some types of logic errors.
		+ fields for a given particle (type and diameter)
			-> get_fields(particle_id: Uuid) -> Vec<FieldInfo>;

Simulation Logic
	- Write a method that will run on each tick to update the state of
		everything in the simulation.
		+ fn tick();
		+ Apply field effects.
			-> For each field on each particle, get a list of particles inside
				the field radius (if the field affects other particles),
				including the particle that owns the field (if the field affects
				the owning particle) and call the field's apply_effect() method,
				passing in references to (or particle_ids of?) the affected
				particles.
				- This logic requires O(n^2) function calls, where n is the
					number of particles within the radii of each other's fields.
					In the worst case, n is all of the particles in the
					simulation. This is probably something to attempt to
					optimize in the future (but not for v0).
					-> Determining which particles are within each field,
						before even calling the field effect functions, will
						also be O(n^2) (really O(mn), where m is the number of
						fields and n is the number of particles in the
						simulation).
		+ Apply forces, setting acceleration.
			-> Iterate through all particles, calculating a = (f / m) for each.
			-> a = (sum(f0, f1, f2...)/m)
		+ Apply acceleration, changing velocity.
			-> Iterate through all particles, calculating
				v = v + (a * tick_duration) for each.
			-> Remember to do this for each component of the velocity vector.
		+ Move the particles, as dictated by their velocities.
			-> Multiply each component of the velocity vector by the tick
				duration to get a displacement vector.
			-> Add each component of the displacement vector to each component
				of the position.

Simulation Struct
	- Represents the state of the entire simulation.
	- Provides most (all?) of the methods/logic mentioned in the "Interface"
		section above.
	- Data
		+ It probably makes sense to use custom types (the "newtype" pattern
			mentioned later in these notes) for most things. Eventually, I will
			want to change the types that I use for all operations in ways that
			will likely require changes to the math used, but not to the logic
			of the physics simulation. For example, a change from floating point
			numbers to fixed point numbers or "Planck lengths" wouldn't change
			the simulation logic, but will change the details of the math. It's
			probably not bad to have the compiler enforce rules about which
			physical quantities can be used together either (e.g. prevent time
			from being added to mass, force multiplication of velocity by time
			to take place via a method that returns displacement).
		+ tick duration
			-> Seconds type
		+ collection owning all particles
			-> A HashMap. We will want to access particles by ID and Rust's
				HashMap type provides iter() and iter_mut() methods for
				iteration over the entire map.
		+ elapsed ticks
		+ elapsed simulated time
			-> Calculated from elapsed ticks and tick duration. Probably a
				method, not a variable.
		+ simulation speed (realtime, faster than realtime, slower than realtime)
			-> 1 second/second for realtime simulation
			-> Greater than 1 second/second for fast-forward
			-> Less than 1 second for slow motion
			-> Negative or None to simulate as quickly as possible.
				- Probably use an Option<some_unsigned_type> and use None for
					max speed.
			-> Should this just be a floating point value, or should it have a
				special type? Maybe I could create some unitless "Coefficient"
				type for values like this. Maybe implement a "NonNeg" type to
				represent float values that must be 0 or greater. Is it best to
				just use an f64 for v0?
		+ on_tick
			-> A user-defined callback function, called by the simulation on
				each tick.
			-> Option</*function pointer*/>
	- Methods
		+ fn tick()
			-> I probably need some way to either make the physics engine call
				code written by the user (other than field methods) or to make
				user code responsible for driving the physics engine (e.g., by
				calling step() or tick() repeatedly with the correct frequency).
				- Making the physics engine call user code is probably a better
					choice than making the user code responsible for driving the
					simulation. I can probably add a function pointer to the
					Simulation struct to be populated by the user.
				- See "on_tick" above.
			-> Apply field effects.
				- For each field on each particle, get a list of particles
					inside the field radius (if the field affects other
					particles), including the particle that owns the field (if
					the field affects the owning particle) and call the field's
					apply_effect() method, passing in references to (or
					particle_ids of?) the affected particles.
				- Add particles and fields to a collection to apply field
					effects after done searching for fields or apply field
					effects in each iteration of the loop that finds the fields?
					+ What happens if a field does something that interferes		[bad things (non-determinism)]
						with finding other particles within this loop (e.g.,
						deleting a particle)?
					+ What happens if a field does with the application of field	[bad things (non-determinism)]
						effects after the loop that finds the fields?
						-> Interfering with finding particles within the loop is
							probably less potentially disruptive than
							interfering with effects being applied later. For
							example, deleting a particle while searching for
							fields just means the deleted particle won't be
							found. Deleting a particle after adding its ID to
							a collection, then attempting to apply effects to
							that particle by ID later would cause a panic.
							However, the panic could be avoided by just checking
							that each particle still exists before attempting
							to apply effects.
					+ Running field effects while finding fields or just adding
						them to a collection and allowing them to interfere
						with each other's execution will both result in
						non-deterministic behavior within a tick. In either
						case, there's no accounting for the order in which
						particles will be, for example, deleted. Sometimes
						forces may be applied by particles deleted in the
						current tick and sometimes particles will be deleted
						before their forces are applied.
						-> The only reasonable thing to do is to come up with
							some way to make sure that all effects of all
							fields that existed at the start of a tick will be
							applied on the current tick.
							- The design of the simulation's interface already
								calls for forcing a user of the library to
								take any action that affects the simulation
								through methods of Simulation. The way to handle
								this is probably just to make all of these methods
								add their actions to collections, in the same way
								that forces are added to a collection. Then have
								tick() execute all of the collected actions in an
								appropriate order. For example, create_particle()
								would add something to a list of create actions
								and delete_particle would add something to a list
								of delete actions. Neither would actually create
								or delete anything. The tick() method would then
								iterate through the collections of create and
								delete requests and perform the actual creation
								and deletion at appropriate points within the tick
								(probably after all forces are executed in the
								case of create/delete).
								+ Remember to modify the particle creation and
									deletion tests. Currently, the create and
									delete tests expect particles to be
									immediately created or deleted. Now it will
									be necessary to check that the simulation is
									carrying out the actual creates and deletes
									when a tick occurs.
						-> Apply forces, setting acceleration, possibly by
							calling a method of Particle.
				- Iterate through all particles, calculating a = (f / m) for
					each.
				- a = (sum(f0, f1, f2...)/m)
				- Problem: The Simulation "self" is borrowed immutably in each
					iteration of the loop that iterates through the particle
					collection to find particles with fields and later borrowed
					mutably to actually apply the field effects. This is a
					borrow error. It seems like the only good(?) way to solve
					this is to implement interior mutability on all of the data
					owned by Simulation.
					+ The only other option is probably to completely redesign		[don't do this]
						and rewrite the physics engine in some way that doesn't
						rely on structs owning mutable data?
					+ Forum post discussing borrow issues in loops:
						https://users.rust-lang.org/t/iterating-over-a-self-some-vec-while-mutating-self/51135
					+ Interior mutability:
						https://doc.rust-lang.org/book/ch15-05-interior-mutability.html
						-> RefCell will cause a compile-time error in a
							"multithreaded context." However, if I do make a
							multithreaded version of this, there is a way to get
							similar functionality to RefCell (apparently in
							chapter 16 of The Book).
					+ It seems like I need to modify all of the methods that
						take a mutable reference to a Simulation to instead take
						an immutable reference. The data members used by those
						methods would be moved into RefCells and the methods
						would take mutable borrows from the RefCells.
			-> Apply acceleration, changing velocity, possibly by calling a
				method of Particle.
				- Iterate through all particles, calculating
					v = v + (a * tick_duration) for each.
				- Remember to do this for each component of the velocity
					vector.
			-> Move the particles, as dictated by their velocities, possibly by
				calling a method of Particle.
				- Multiply each component of the velocity vector by the tick
					duration to get a displacement vector.
				- Add each component of the displacement vector to each
					component of the position.
		+ To support the requirements listed under "Interface", above:
			-> Create particles.
				+ fn create_particle(position: Vector2 /* or Position */,
					mass: /* number */, fields: Vec<Field>)
					-> /* particle ID: */ Uuid;
			-> Delete particles.
				+ fn delete_particle(particle_id: Uuid);
			-> Apply forces to particles.
				+ apply_force(particle_id: Uuid, force: Vector2 /* or Force */)
			-> Start, pause, and advance the simulation by a single step.
				+ start();
				+ pause();
				+ step();
			-> Constructor
				+ Simulation::new(speed: /* number */, tick_length: /* number */)
					-> Simulation;
			-> Return the number of elapsed ticks since simulation start.
				- get_elapsed_ticks() -> /* number or Tick */;
					+ Possibly useful to alias a numeric type as Tick. Allows
						all references to Tick to be changed to a different
						underlying type if desired and might make the compiler
						catch some logic errors.
						-> Don't actually create a type alias if having the
							compiler enforce typing based on that name is
							desired. When a type alias is used, the compiler
							still treats the alias as the underlying type. For
							example, if u64 was aliased to "Mass", the compiler
							would still allow u64 to be added to Mass. What I
							might want to do, to get the compiler to enforce
							the type, is referred to as the "newtype" pattern,
							as described in this section of the book:
							https://doc.rust-lang.org/book/ch20-02-advanced-traits.html#default-generic-type-parameters-and-operator-overloading
			-> Return the elapsed time (simulated seconds) since simulation
				start.
				- get_elapsed_time() -> /* number or SimTime */:
					+ Possibly useful to alias a numeric type as SimTime.
						Allows all references to SimTime to be changed to a
						different underlying type if desired and might make the
						compiler catch some logic errors.
			-> Read information necessary/useful to render the simulation.
				- particle position
					+ get_position(particle_id: Uuid) -> Vector2 /* or Position */;
				- particle mass
					+ get_mass(particle_id: Uuid) -> /* number or Mass */;
						-> It's probably a good idea to alias (actually, use the
							"newtype" pattern) a numeric type as Mass. Then, it
							should be possible to change the underlying type in
							just one place if desired. This also makes the type
							system prevent some types of logic errors.
				- fields for a given particle (type and diameter)
					+ get_fields(particle_id: Uuid) -> Vec<FieldInfo>;

Vector2 Struct (not to be confused with Vec)
	- Stores a 2d vector.
	- Possibly a tuple struct.
	- Provides methods for 2d vector math.
	- May be wrapped by structs used for describing specific vector quantities
		(e.g. Force, Position, Velocity, Acceleration), if useful. Each of these
		vector quantity structs could then implement their own methods that rely
		on Vector2 but perform specific tasks (e.g. apply a force to produce an
		acceleration). Having different structs for different types of vector
		quantity may also be helpful as a way of making the compiler check for
		logic errors arising from applying the wrong kind of vector in a given
		context (e.g., trying to add a force vector to an acceleration vector
		would result in a compiler error instead of a confusing bug).

Particle Struct
	- Tracks (and owns) all information pertaining to an individual particle.
	- Mass
	- Position
	- Velocity
	- Acceleration during the current or next tick?
	- Fields produced by the particle
	- Unique particle ID

Interactions
	- Particles will only interact with each other via fields. There will be no
		explicit collision detection (just bounds checking on fields).
	- Particles are point objects: they have no length, height, or area. Fields
		will have radii.

Fields
	- Each particle can have an arbitrary number of fields attached.
	- A field consists of a radius and an effect.
		+ Any particle, other than the particle to which the field is attached,
			will trigger the field's effect when it is within the field during a
			given tick.
			-> Maybe include two Boolean variables to determine whether the
				field affects the owning particle and whether the field affects
				other particles.
		+ A field's effect is determined by an arbitrary function (maybe a
			method of a Field struct).
			-> Rust does appear to support function pointers, so a field struct
				containing a function pointer may be viable, but it might be
				better (at least for v0) to define different types of field
				struct with specific methods defined at compile time.
				- For v0, define a Field trait as part of the library and allow
					callers to define individual fields. Maybe define a few
					preset field structs within the library if convenient.

Gravity
	- Gravity, if it exists, will be a field.
		+ If I want to make a room/floor with gravity, I can probably lock a
			particle, or a floor made up of multiple particles, in place by
			giving it infinite (or very high) mass. I could add a gravity field
			to that particle or floor.
		+ I could make all (or a subset) of particles experience a gravitational
			force in a set direction if I provide the option for fields to
			affect the particles to which they are attached. Then any particle
			that should be affected by gravity would just have a self-affecting
			gravity field attached.

Ticks
	- Each tick represents some amount of time.
	- For realtime simulation, it will be necessary to perform as close to
		exactly the number of ticks that represent a given amount of time within
		that amount of time as possible. For example, if we were not simulating
		in real time, it would be desirable to simulate as quickly as possible.
		There would be nothing wrong with simulating 10,000 seconds in one
		second of real time. However, if we want to interact with the
		simulation, we want it to simulate as close to 1 second per real time
		second as possible.
	- Include a parameter to adjust maximum simulation speed.
		+ 1 second/second for realtime simulation
		+ Greater than 1 second/second for fast-forward
		+ Less than 1 second for slow motion
		+ Negative or None to simulate as quickly as possible.
			-> Probably use an Option<some_unsigned_type> and use None for max
				speed.

Modules
	- physical_quantities
		+ Contains all of the structs representing physical quantities (e.g.,
			Time, Velocity, Vector2, Force) and their impl blocks.
	- simulation
		+ Contains the Simulation struct and its impl block.
	- simulation_objects
		+ Defines physical things that will exist within the simulation, such
			as Field and Particle structs.

Graphics
	- Research rust graphics/animation/visualization libraries. Simpler is
		better.
	- It might be convenient and fun to try the graphics library out by using it
		to create visuals for the "trajectory_calculator" program.

Colliders:

	Velocities after a 1D collision between particle a and particle b:
		v_a = (C_R * m_b * (u_b - u_a) + m_a * u_a + m_b * u_b) / (m_a + m_b)
		v_b = (C_R * m_a * (u_a - u_b) + m_b * u_b + m_a * u_b) / (m_b + m_a)
	Where
		v_a is the final velocity of the first object after impact
		v_b is the final velocity of the second object after impact
		u_a is the initial velocity of the first object before impact
		u_b is the initial velocity of the second object before impact
		m_a is the mass of the first object
		m_b is the mass of the second object
		C_R is the coefficient of restitution
	
	For two and three-dimensional collisions, all velocities in these formulas
		are the components perpendicular to the tangent line or plane at the
		point of contact. Remember that this applies to both the initial
		velocities, u, and the final velocities, v. This means that the total
		velocity of a particle should almost never be set to v_a or v_b. Think
		about how two objects would behave in a glancing collision, rather than
		a perfectly head-on collision.
	
	It's very unlikely that the "tangent" will actually be a tangent in a
		simulated collision. There will almost always be an overlap between two
		collider fields in the tick where the collision is detected. The
		"tangent" will actually be a secant defined by the two points where the
		two fields overlap. It probably makes sense to never even check for a
		real tangent, opting to instead wait until a secant exists to consider
		a collision to have occurred. Checking for overlap between two circles
		is just done by checking for the condition where distance between the
		circles' centers is less than the sum of the circles' radii. Checking
		for the existence of a secant (not finding the actual secant) just
		requires us to check for strict inequality, '<'. An actual tangent
		would only exist in the case where the distance between centers equals
		the sum of the radii.
		- It turns out that finding a general formula for the two points where
			two circles overlap is not easy. However, it may not be necessary.
			See https://www.plasmaphysics.org.uk/collision2d.htm and pay
			attention to the part about "impact angle".
			+ This same website also has a page explaining how to find the
				needed angles for three-dimensional collisions:
				https://www.plasmaphysics.org.uk/collision3d.htm
			+ If I use the formulas from this webpage, I'll need to calculate
				angles and run trigonometric functions (e.g. arcsin). The f64
				type has built in support for trig functions, with inputs given
				in radians. The f64 type also has a PI constant. If I need to
				convert between degrees and radians (if I can't just get my
				angles in radians from the start) I should precompute PI/180 at
				the start of the program to get the conversion factor between
				degrees and radians with high precsion without wasting time
				computing it during tick().
				-> https://doc.rust-lang.org/std/primitive.f64.html
	
	Probably make a collider field that only interacts with other particles with
		collider fields and calculates the force that would set the other
		(for consistency with UniversalGravitationField) particle's velocity
		component perpendicular to the tangent (actually the secant defined by
		two overlapping circles) to 0 within a single tick, then apply that
		force to the other particle. This should still work when collisions
		between three or more particles occur.
		- Requires two changes to the physics engine (in addition to implementing	[done]
			the Field):
			+ Add a get_tick_duration() method.										[done]
			+ Add support for applying field effects when two fields overlap,
				not just when a particle is within a field.
				-> Write unit tests before implementing this change.				[done]
					- simulation_field_affects_others_fields_overlap()
					- simulation_field_does_not_double_trigger()
					- simulation_particle_with_two_fields_does_not_self_trigger()
				-> Add two new Field methods (probably returning bools): one to		[done]
					indicate whether a field effect triggers when overlapping a
					field and one to indicate whether a field effect triggers
					when that field contains a particle.
					- An option to do both might make sense. When two particles
						have fields with equal radii, both fields overlapping
						both particles is a special case of both fields
						overlapping. However, if only one of the two particles
						has a field, or if the particles have fields with
						different radii, it's possible for one particle's field
						to overlap the other particle without the second
						particle's field overlapping the first particle or its
						field.
				-> Add code to tick() to handle overlapping fields similarly to		[done]
					how it handles particles within fields.
					- Remember that it will be necessary to avoid double-adding
						the same particle to the collection of particles
						affected by a field if that field's effect triggers on
						both field/field overlap and field/particle overlap.
		- It is probably necessary to avoid applying any forces if the colliding
			particles' velocities are such that the particles are already
			separating, so we don't apply collision forces repeatedly after the
			collision has already occurred. I.e., the particles' relative
			velocities must be towards each other.
			+ There may be some kind of challenge in determining which direction is
				"separating" the particles. Consider the overlap between two fields
				and the relative velocities of the corresponding particles one tick
				after a glancing collision.
				-> Possible logic: If the component of the particle's velocity
					normal to the secant is zero or negative (if positive
					velocity is in the direction of the other particle), don't
					run the collision logic. The component normal to the secant
					doesn't need to be thought of as a vector. It will be a
					one-dimensional velocity found by trigonometry.
		- Don't forget to handle the edge case where one smaller collider is
			completely enclosed within a larger collider.
			+ Remember to write a test for this.
		- Don't forget to handle the corner case where two colliders with equal
			radius are located exactly on top of each other (i.e., their
			particles have exactly the same position).
			+ This may be so unlikely that it can be ignored in most cases,
				given that position is two f64 values. However, it is possible
				for the user to intentionally create two particles with exactly
				equal positions.
			+ Remember to write a test for this.


________________________________________________________________________________

Custom screensaver?
	- There are xscreensaver rust bindings, apparently. I might be able to make
		a custom screensaver that generates and simulates random arrangements of
		particles with random properties and field parameters.

Make a small game?
	- Probably won't be able to do much with this iteration. It's unlikely to
		be performant.

To remember for future iterations:
	- Consider making Vector2 a trait, instead of a struct. This would allow it
		to provide default implementations for common vector operations, like
		magnitude (and maybe std::ops?) instead of having to implement a method
		for each operation in each type that relies on Vector2. This would also
		allow functions to accept any Vector2, instead of being limited to just
		Velocity or just Displacement (like the "almost_equal" functions), for
		example.
	- To eliminate floating point errors, do all calculations in integer
		multiples of a "Planck length" or use fixed point numbers. Look into
		using GMP (see bookmarks in browser).
	- Combine particles into larger objects (meshes, rigid bodies) and change
		the simulation scale and precision dynamically when useful (based on
		speed or maybe distance between particles? other factors?).
	- See notes in Joplin and paper notes in the black folder.
	- Optimize the algorithm for finding neighboring particles and applying
		field effects in the "Apply field effects" step described under
		"Simulation Logic", above. As described currently (2025-05-22), it will
		probably be a significant bottleneck. Without any optimization, in
		addition to the n^2 (m * n) function calls each of the m fields may need
		to make, each field will need to iterate through all n particles in the
		simulation to determine whether each of those particles falls within the
		field's radius. This will need to be done for each of the fields in the
		simulation.
		+ There are definitely data structures and algorithms for finding items
			within a radius or within a grid cell. Do some research to find
			something useful.
			-> Once I decide on an option, see if there's a good rust crate
				that implements the desired data structure or algorithms. If
				not, implement it as its own crate and publish it to crates.io.
			-> Possible Options:
				- Quadtree
				- R-tree
				- Spatial hash map
				- K-d tree
				- Bounding volume hierarchy (BVH)
				- Others?
	- It may be necessary to shrink HashMaps from time to time to avoid wasting
		memory and unnecessarily slowing down operations that need to iterate
		over all particles. When items are added to a HashMap, it eventually
		needs to increase its capacity to hold them. It's not clear to me if the
		capacity is ever reduced automatically when items are removed. Iterating
		over all elements of a HashMap takes linear time in the map's capacity,
		not in the number of elements it holds. See the HashMap.shrink_to_fit()
		method's documentation if considering shrinking the map after a number
		of deletions.


DONE:

	Change how acceleration and displacement ("coasting") are handled in tick().
		Currently, we are (incorrectly) setting the velocity to what it should
		be at the very end of the tick, then changing position based on that new
		velocity. This ignores the smaller change in position that should happen
		as a particle is being accelerated, instead calculating the entire
		change in position based on the peak velocity that would occur during
		that tick. Acceleration and displacement need to be handled together to
		calculate the change in position due to velocity at the start of the
		tick and velocity throughout the tick due to acceleration.
		- To calculate the new velocity:
			v = v_0 + a * t
			v = v_0 + (f / m) * t
		- To calculate the new position:
			d = d_0 + v_0 * t + 0.5 * a * t^2
			d = d_0 + v_0 * t + 0.5 * (f / m) * t^2
	
	Add code to run the simulation in real time. Do I have notes on this?
		- Check below.
		- From playing with the physics engine to make demos, it seems like
			there is something wrong with how step_synchronized() (and,
			presumably, start()) calls tick(). It's probably not actually
			synchronizing with real time correctly. The unit tests that call
			step() pass, so the issue is probably related to how often tick is
			actually getting called. I should probably add code to start() and
			step_synchronized() to track how much real time has elapsed between
			ticks and either call tick multiple times to catch up or skip calls
			to it to let real time catch up.
			+ Skipping calls already happens. The original intention was to
				have simulation speed be a maximum speed achievable based on
				system performance. The same number of ticks per simulated
				second will always occur, regardless of how much real-world
				time passes between calls to tick(). Calling tick() more
				frequently when system performance is already preventing it from
				being called at the desired rate is probably not a reasonable
				thing to attempt.
			+ If changing how many ticks a single call to step_synchronized
				performs, any calls to methods like apply_force() that take
				place outside of the simulation's control (like the forces I'm
				applying in the demos) will result in non-deterministic
				behavior.
				-> I either need to find some way to make this work or avoid
					calling any methods that affect the simulation outside of
					Field.effect() or simulation.on_tick.
				-> Is there already something wrong with calling apply_force()
					from outside the simulation? Is it actually necessary to
					make step_synchronized() call tick() more than once? It
					currently doesn't make the tick() call each time it's
					called. Is that causing apply_force() to behave differently
					based on tick duration when called from outside?
					- Yes, calling apply_force() from outside the simulation
						can cause non-determinism in the current implementation.
						If step_synchronized() doesn't call tick() each time
						it's called, apply_force() will be called multiple
						times in a single tick. It's either necessary to
						somehow have step_synchronized() compensate for this
						(may be hard) or document it in all of the methods		[done]
						that may experience non-deterministic behavior to
						inform that user that it is necessary to compensate for
						it (by checking Simulation.get_elapsed_ticks() or
						whatever I called it) or avoid making such calls from
						outside the simulation (outside on_tick and effect()).

	There is a problem with my implementation of support for effects triggering
		on overlapping fields. There is currently no way for a field's effect()
		method to know which field triggered it. If a particle has two fields,
		a and b, of differing sizes and the triggered field only wants to
		affect the particle when field b is encountered, we need some way to
		allow it to choose to ignore field a. For example, we don't want a
		collider with radius 5.0 to to run collision logic when encountering a
		gravity field with radius 1000.0.
		- Remember to implement a unit test to determine whether a list of 			[done]
			overlapped fields is successfully provided to the effect() method.
		- How to inform each effect of all fields with which its field overlaps
			for each particle it's affecting?
			+ Instead of passing a Vec of particle IDs, pass a Hashmap of Vecs
				of FieldInfo, keyed by particle ID.
