V0 Goals:
	- Write a minimal, single-threaded, 2d physics engine and create a realtime
		graphical demo of it in action.
	- Simulate an arbitary number of particles.
		+ Forces
		+ Position
		+ Velocity
		+ Fields

Testing
	- The physics engine should be a library with unit (and integration?) tests.
	- A useful category of tests might be tests that apply known forces or
		velocities to particles and compare the results to the predictions of
		classical mechanics formulas for position, velocity, kinetic energy,
		etc. Due to the tick-based, discrete nature of the simulation, these
		tests will need to allow for some margin of error, based on the tick
		length and other precision settings.

Vector2 Struct (not to be confused with Vec):
	- Stores a 2d vector.
	- Possible a tuple struct.
	- Provides methods for 2d vector math.
	- May be wrapped by structs used for describing specific vector quantities
		(e.g. Force, Position, Velocity, Acceleration), if useful. Each of these
		vector quantity structs could then implement their own methods that rely
		on Vector2 but perform specific tasks (e.g. apply a force to produce an
		acceleration). Having different structs for different types of vector
		quantity may also be helpful as a way of making the compiler check for
		logic errors arising from applying the wrong kind of vector in a given
		context (e.g., trying to add a force vector to an acceleration vector
		would result in a compiler error instead of a confusing bug).

Particle Struct
	- Tracks all information pertaining to an individual particle.
	- Mass
	- Position
	- Velocity
	- Acceleration during the current or next tick?
	- Fields produced by the particle
	- Unique particle ID

Interactions
	- Particles will only interact with each other via fields. There will be no
		explicit collision detection (just bounds checking on fields).
	- Particles are point objects: they have no length, height, or area. Fields
		will have radii.

Fields
	- Each particle can have an arbitrary number of fields attached.
	- A field consists of a radius and an effect.
		+ Any particle, other than the particle to which the field is attached,
			will trigger the field's effect when it is within the field during a
			given tick.
		+ A field's effect is determined by an arbitrary function (maybe a
			method of a Field struct).
			-> Rust does appear to support function pointers, so a field struct
				containing a function pointer may be viable, but it might be
				better (at least for v0) to define different types of field
				struct with specific methods defined at compile time.

Gravity
	- Gravity, if it exists, will be a field.
		+ If I want to make a room/floor with gravity, I can probably lock a
			particle, or a floor made up of multiple particles, in place by
			giving it infinite (or very high) mass. I could add a gravity field
			to that particle or floor.

Ticks
	- Each tick represents some amount of time.
	- For realtime simulation, it will be necessary to perform as close to
		exactly the number of ticks that represent a given amount of time within
		that amount of time as possible. For example, if we were not simulating
		in real time, it would be desirable to simulate as quickly as possible.
		There would be nothing wrong with simulating 10,000 seconds in one
		second of real time. However, if we want to interact with the
		simulation, we want it to simulate as close to 1 second per real time
		second as possible.
	- Include a parameter to adjust maximum simulation speed.
		+ 1 second/second for realtime simulation
		+ Greater than 1 second/second for fast-forward
		+ Less than 1 second for slow motion
		+ Negative or None to simulate as quickly as possible.
			-> Probably use an Option<some_unsigned_type> and use None for max
				speed.

Applying a force (per tick):
	- Calculate the acceleration: a = (sum(f0, f1, f2...)/m)
		+ Remember to do this for each component of the acceleration vector.
	- Calculate the new velocity: v = a * tick_duration
		+ Remember to do this for each component of the velocity vector.

Moving a particle (per tick):
	- Multiply each component of the velocity vector by the tick duration to get
		a displacement vector.
	- Add each component of the displacement vector to each component of the
		position.

Graphics
	- Research rust graphics/animation/visualization libraries. Simpler is
		better.
	- It might be convenient and fun to try the graphics library out by using it
		to create visuals for the "trajectory_calculator" program.


________________________________________________________________________________

To remember for future iterations:
	- To eliminate floating point errors, do all calculations in integer
		multiples of a "Planck length" or use fixed point numbers. Look into
		using GMP (see bookmarks in browser).
	- Combine particles into larger objects (meshes, rigid bodies) and change
		the simulation scale and precision dynamically when useful (based on
		speed or maybe distance between particles? other factors?).
	- See notes in Joplin and paper notes in the black folder.
